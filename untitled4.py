# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nZ9r9YNnpHzftg8FYtwp13v8BgL35vMg
"""

from imutils import contours
from skimage import measure
import numpy as np
import matplotlib.pyplot as plt
import argparse
import imutils
import cv2

img_address = input()



image = cv2.imread(img_address)
plt.imshow(image)
imf = image.copy()

def canny(im):
  BLUR = 21
  CANNY_THRESH_1 = 10
  CANNY_THRESH_2 = 250
  MASK_DILATE_ITER = 10
  MASK_ERODE_ITER = 10
  MASK_COLOR = (255.0,255.0,255.0) # In BGR format
  img = np.asarray(imf)
  gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
  edges = cv2.Canny(gray, CANNY_THRESH_1, CANNY_THRESH_2)
  edges = cv2.dilate(edges, None)
  edges = cv2.erode(edges, None)
  contour_info = []
  _, contours, _ = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)
  for c in contours:
      contour_info.append((
          c,
          cv2.isContourConvex(c),
          cv2.contourArea(c),
      ))
  contour_info = sorted(contour_info, key=lambda c: c[2], reverse=True)
  max_contour = contour_info[0]
  mask = np.zeros(edges.shape)
  cv2.fillConvexPoly(mask, max_contour[0], (255))
  mask = cv2.dilate(mask, None, iterations=MASK_DILATE_ITER)
  mask = cv2.erode(mask, None, iterations=MASK_ERODE_ITER)
  mask = cv2.GaussianBlur(mask, (BLUR, BLUR), 0)
  mask_stack = np.dstack([mask]*3)    # Create 3-channel alpha mask

  
  mask_stack  = mask_stack.astype('float32') / 255.0          # Use float matrices, 
  img         = img.astype('float32') / 255.0                 # for easy blending

  masked = (mask_stack * img) + ((1-mask_stack) * MASK_COLOR) # Blend
  masked = (masked * 255).astype('uint8')     
    
  c_red, c_green, c_blue = cv2.split(img)
  img_a = cv2.merge((c_red, c_green, c_blue, mask.astype('float32') / 255.0))
  
  x = 70 
  y = 280
  w = 440
  h = 100 
  crop_img = im[y:y+h, x:x+w]
  return crop_img
 
crop = canny(image)
plt.imshow(crop)


crop.shape
image.shape

cropimg1 = cv2.cvtColor(crop,cv2.COLOR_BGR2GRAY) # or convert
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
cl1 = clahe.apply(cropimg1)
plt.imshow(cl1)

gamma = 1.5 # Gamma < 1 ~ Dark  ;  Gamma > 1 ~ Bright

gamma_correction = ((cl1/255) ** (1/gamma)) 
plt.figure(figsize = (5,5))
plt.imshow(gamma_correction)



newarr = np.asarray([[1,1,1,1], [1,1,1,1],[1,1,1,1]])
from scipy.ndimage import convolve
x = convolve(gamma_correction,newarr)
plt.imshow(x)
plt.show()

newarr = np.asarray([[1,1,1,1], [1,1,1,1],[1,1,1,1]])
from scipy.ndimage import convolve
x = convolve(gamma_correction,newarr)
plt.imshow(x)
plt.show()

copy = x.copy()

mini = x.min()
maxi = x.max()

x = (255/(maxi-mini))*(x-mini)
img2 = np.zeros(x.shape)

for i in range(0,x.shape[0]-5):
  for j in range(0,x.shape[1]-5):
    if(x[i][j]>30):
      x[i][j] = 0
    else:
      x[i][j] = 255
    
plt.imshow(x)
plt.show()



x.max()

x.min()

plt.hist(x.reshape(x.shape[0]*x.shape[1]))

